<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Teste Pagamento Wallet v12</title>
  <style>
    body { font-family: monospace; }
    .ok { color: green; }
    .err { color: red; }
    .step { color: blue; }
  </style>
</head>
<body>

<h3>Teste de Pagamento (Somente On-chain)</h3>

<button id="btnPay">Pagar agora</button>

<pre id="log"></pre>

<script type="module">
  import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6.8.1/+esm";

  const logEl = document.getElementById("log");
  const log = (m) => logEl.textContent += m + "\n";

  const CFG = {
    chainId: 56,
    chainHex: "0x38",

    tokenAddress: "0xa131ebbfB81118F1A7228A54Cc435e1E86744EB8",
    paymentContract: "0xcf1Fe056d9E20f419873f42B4d87d243B6583bBD",

    tokenABI: [
      "function approve(address,uint256) returns (bool)",
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address,address) view returns (uint256)"
    ],

    paymentABI: [
      "function payForAnalysis()",
      "function pricePerAnalysis() view returns (uint256)",
      "event AnalysisPaid(address indexed user, uint256 amount)"
    ]
  };

  document.getElementById("btnPay").onclick = async () => {
    try {
      log("ğŸ”— Conectando carteira...");

      if (!window.ethereum) {
        throw new Error("MetaMask nÃ£o encontrada");
      }

      const provider = new ethers.BrowserProvider(window.ethereum, "any");
      await provider.send("eth_requestAccounts", []);
      let signer = await provider.getSigner();
      const wallet = await signer.getAddress();

      log("ğŸ‘› Wallet: " + wallet);

      const net = await provider.getNetwork();
      if (Number(net.chainId) !== CFG.chainId) {
        log("ğŸ” Trocando para BSC...");
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: CFG.chainHex }]
        });
        signer = await provider.getSigner();
      }

      log("ğŸ“¦ Conectando contratos...");

      const token = new ethers.Contract(
        CFG.tokenAddress,
        CFG.tokenABI,
        signer
      );

      const payment = new ethers.Contract(
        CFG.paymentContract,
        CFG.paymentABI,
        signer
      );

      const price = await payment.pricePerAnalysis();
      const balance = await token.balanceOf(wallet);

      log("ğŸ’° PreÃ§o: " + price.toString());
      log("ğŸ’° Saldo: " + balance.toString());

      if (balance < price) {
        throw new Error("Saldo insuficiente");
      }

      const allowance = await token.allowance(wallet, CFG.paymentContract);

      if (allowance < price) {
        log("ğŸ“ Aprovando token...");
        const txApprove = await token.approve(CFG.paymentContract, price);
        await txApprove.wait();
        log("âœ” Approve confirmado");
      } else {
        log("âœ” Approve jÃ¡ existente");
      }

      log("ğŸ’¸ Executando pagamento...");
      const txPay = await payment.payForAnalysis();
      log("â³ Tx enviada: " + txPay.hash);

      const receipt = await txPay.wait();

      log("âœ… PAGAMENTO CONCLUÃDO");
      log("ğŸ“œ Tx Hash: " + receipt.hash);

    } catch (e) {
      log("âŒ ERRO:");
      log(e.message || e);
    }
  };
</script>

</body>
</html>
